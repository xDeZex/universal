# Claude Coding Guidelines for Shopping List App

## Project Overview
This is a Flutter shopping list application with persistent storage and drag-and-drop reordering capabilities.

## Coding Standards & Preferences

DO NOT EDIT THIS FILE

---

### How to speak
- I am not perfect, I make mistakes, do not praise me, do not agree with everything I say

### Flutter & Dart Guidelines
- Use Material 3 design (`useMaterial3: true`)
- Prefer `const` constructors where possible
- Use meaningful variable and class names in English
- Follow Flutter naming conventions:
  - camelCase for variables and methods
  - PascalCase for classes
- Always add a `key` parameter to stateless widgets
- Use the `late` keyword appropriately for late initialization

---

### State Management
- Use the Provider pattern for app state management
- Keep business logic in the main app state class
- Call `notifyListeners()` after state changes
- Always save data to storage after state modifications

---

### Error Handling
- Wrap async operations in `try`-`catch` blocks
- Use null-safe operators (`?`, `??`, `!`)
- Provide fallback values for potential null cases
- Print errors for debugging, but do not crash the app

---

### Swedish Language Support
- Test with Swedish characters: å, ä, ö, Å, Ä, Ö
- Use proper localization delegates for Material widgets
- Only perform a few basic tests with Swedish characters; no need to test every feature

---

### Storage & Persistence
- Auto-save all data changes using `SharedPreferences`
- Implement proper JSON serialization with `toJson()` and `fromJson()`
- Load data asynchronously in constructors or `initState`
- Handle storage errors gracefully

---

### UI/UX Preferences
- Use `Card` widgets for list items with consistent margins
- Show confirmation dialogs for destructive actions (delete)
- Implement proper drag handles for reorderable lists
- Use semantic colors (e.g., `Colors.grey` for completed items)
- Keep floating action buttons (`+`) for primary actions
- Define a theme and use colors and sizes from that theme

---

### Code Organization
- Keep models in separate files under `lib/models/`
- Keep screens in separate files under `lib/screens/`
- Organize import statements:
  1. `dart:` imports first
  2. package imports
  3. relative imports
- Use meaningful file and folder names

---

### Code Quality
- Keep nesting to a reasonable level
- Prefer using local classes to improve readability
- Follow the ideas of Martin Fowler and Kent Beck
- Favor small, well-named functions over long functions with explanatory comments
- If comments are needed, explain why the code works a certain way
- Remove unused imports and unused code
- Run `flutter analyze` to find and fix warnings

---

### Testing & Quality
- Run `flutter pub get` after adding dependencies
- Always write unit tests for new code
- Run unit tests to verify that old and new functionality work
- Do not change unrelated tests
- Do not change tests to make them pass — if they fail, the code is wrong
- Failing tests are never acceptable — fixing them is the top priority
- **CRITICAL: Never complete a task or mark work as "done" if ANY tests are failing**
- **CRITICAL: Always run `flutter test` before claiming work is complete**
- **CRITICAL: If ANY test fails after changes, immediately fix the issue or revert the changes**
- Before refactoring:
  - Run tests first; if there are failures, fix them before refactoring
- If tests fail after refactoring:
  - Undo the refactoring entirely; do not modify the tests
- Fix all failing tests — there are no "optional" tests
- Write tests that are stable and not brittle
- Run the whole suite of tests when testing the app
- **MANDATORY: End every session with `flutter test` to verify all tests pass**
- **If tests fail, do not proceed with commits, refactoring, or new features**

---

### Code Writing Guidelines
- When writing code follow “Red-Green-Refactor”:
  1. Write tests for new functionality
  2. Write the code
  3. When tests pass, refactor
- Write tests for a new functionality before implementing the new functionality
- When told to only write tests, do not write any code even if the new tests fail
---

### Environment
- After making a change, do not automatically run a hot reload or hot restart; the user will trigger it manually
- Development environment:
  - Android emulator
  - Debugging from VS Code

---

### Git
- Commit messages should be short, to the point, and only mention new changes
- Commit all changes unless told otherwise
- Run tests before committing; only commit if all tests pass
- Use `git add --all`

---

## Development Commands
- Install dependencies: `flutter pub get`
- Hot reload: Press `r` in terminal
- Hot restart: Press `R` in terminal
- Build: `flutter build apk`

## Modularity & Architecture

Use these when refactoring and general coding

### Code Structure
- **Single Responsibility Principle**: Each class/function should have one reason to change
- **Separation of Concerns**: Keep UI, business logic, and data access separate
- Create dedicated service classes for external operations (API calls, storage, etc.)
- Use dependency injection where appropriate
- Keep widget classes focused on UI only - extract business logic to separate classes

### File Organization
```
lib/
├── models/          # Data models only
├── services/        # Business logic, API calls, storage
├── screens/         # UI screens/pages
├── widgets/         # Reusable UI components
├── providers/       # State management
└── utils/           # Helper functions, constants
```

### Function & Class Design
- **Maximum function length**: 20-25 lines (prefer smaller)
- **Maximum class length**: 200-300 lines
- Extract complex widget trees into separate widget classes
- Use composition over inheritance
- Create builder methods for complex UI components
- Extract magic numbers and strings to named constants

### Widget Modularity
- Extract reusable UI components into separate widget files
- Create custom widgets for repeated patterns
- Use builder pattern for complex configurations
- Prefer stateless widgets when possible
- Keep `build()` methods under 50 lines

### Naming & Readability
- Use descriptive names that explain intent, not implementation
- Prefer `calculateTotalPrice()` over `calc()` or `doMath()`
- Use verbs for functions, nouns for classes/variables
- Avoid abbreviations except for widely understood terms
- Name boolean variables/methods with `is`, `has`, `can`, `should`

### Code Readability Rules
- **No deep nesting**: Maximum 3-4 levels of indentation
- Use early returns to reduce nesting
- Extract complex conditions into well-named boolean variables
- Group related functionality together
- Use blank lines to separate logical sections
- Prefer explicit over implicit - make intent clear

### Refactoring Triggers
When you see any of these patterns, extract to separate methods/classes:
- Repeated code blocks
- Long parameter lists (>4 parameters)
- Complex conditional logic
- Nested callbacks more than 2 levels deep
- Widget trees longer than 10 widgets
- Any TODO comments older than a sprint

### Documentation & Comments
- Write self-documenting code first, comments second
- Comment the "why", not the "what"
- Use doc comments (`///`) for public APIs
- Add examples for complex usage patterns
- Keep comments up-to-date with code changes

## Code Review Checklist
Before considering code complete, verify:
- [ ] Each class has a single, clear responsibility
- [ ] Functions are small and focused
- [ ] No duplicated code
- [ ] Magic numbers/strings are extracted to constants
- [ ] Complex widgets are broken into smaller components
- [ ] Business logic is separated from UI code
- [ ] File structure follows project conventions
- [ ] All tests pass (`flutter test`)

## Anti-Patterns to Avoid
- **God classes**: Classes that do too many things
- **God functions**: Functions longer than 25 lines
- **Deep nesting**: More than 3-4 levels of indentation
- **Magic numbers/strings**: Unexplained constants in code
- **Tight coupling**: Classes that know too much about each other
- **Duplicate code**: Copy-paste programming
- **Mixed concerns**: UI logic mixed with business logic